<!--
This program (The Chameleon Mini Live Debugger) is free software written by
Maxie Dion Schmidt: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

The complete license provided with source distributions of this library is
available at the following link:
https://github.com/maxieds/ChameleonMiniLiveDebugger
-->

<resources>
    <string name="app_name">Chameleon Mini Live Debugger</string>
    <string name="app_display_short_name">Chameleon Live Logger</string>
    <string name="app_desc">GUI and portable logging interface for the Chameleon Mini NFC pentesting boards</string>
    <string name="aboutapp">
        &lt;h1>About the CMLD application&lt;/h1>
        This application is copyright (&lt;i>© 2017-2020&lt;/i>) and developed in the free time of its author Maxie D. Schmidt
        (&lt;a href="mailto:maxieds@gmail.com">maxieds@gmail.com&lt;/a>).
        For all intensive reasonable non-commercial applications this Android application is free to use and modify under the
        GPL provided a link to the original project webpage and the author information remain intact in the revisions:
        &lt;a href="https://github.com/maxieds/ChameleonMiniLiveDebugger">maxieds/ChameleonMiniLiveDebugger&lt;/a>.&lt;br/>&lt;br/>

        &lt;h1>Information about the current build&lt;/h1>
        &lt;ul>
            &lt;li>The Android version of the application is &lt;i>build version &lt;b>%%ANDROID_VERSION_CODE%%&lt;/b>&lt;/i>&lt;/li>
            &lt;li>Android revision &lt;b>&lt;i>%%ANDROID_VERSION_NAME%%&lt;/b>&lt;/i>&lt;/li>
            &lt;li>Application build flavor &lt;b>&lt;i>%%ANDROID_FLAVOR_NAME%%&lt;/b>&lt;/i>&lt;/li>
            &lt;li>Git revision &lt;b>&lt;i>%%GIT_COMMIT_HASH%%&lt;/b>&lt;/i> commited at &lt;b>&lt;i>%%GIT_COMMIT_DATE%%&lt;/b>&lt;/i>&lt;/li>
        &lt;/ul>

        &lt;h1>Documentation and Support&lt;/h1>
        Official documentation for the CMLD application is found on the project
        &lt;a href="https://github.com/maxieds/ChameleonMiniLiveDebugger/wiki">WIKI webpage&lt;/a>. Though the developer has made
        a sincere effort to keep most of the user interface and the command buttons self explanatory after some mild tinkering
        with the Chameleon Mini devices. Testing data, feedback, and future feature requests can all be compiled
        &lt;a href="https://github.com/maxieds/ChameleonMiniLiveDebugger/issues">here&lt;/a> in the official issues queue.

        &lt;h1>Credits&lt;/h1>
        The author thanks
        users, labs and Chameleon Mini device resalers who have donated time and hardware to helping me keep this
        CMLD application running at high quality. Donations of Chameleon Mini hardware have been made available to the
        developer of this application at free or reduced cost by the following contributors and third parties:
        &lt;ul>
            &lt;li>The &lt;b>&lt;i>&lt;u>KAOS team&lt;/u>&lt;/b>&lt;/i> (Kasper and Oswald) and original proprietors of the Chameleon RevG hardware / firmware (&lt;a href="https://shop.kasper.it/">their retail site&lt;/a>)&lt;/li>
            &lt;li>The &lt;b>&lt;i>&lt;u>Lab401 team&lt;/u>&lt;/b>&lt;/i> who have customized the Chameleom RevG devices into the Proxgrind revisions (with Bluetooth) and the Tiny variations (&lt;a href="https://www.facebook.com/pages/category/Electronics/Lab401-306470190007231/">their social media profile&lt;/a>)&lt;/b>&lt;/i>&lt;/li>
            &lt;li>The &lt;b>&lt;i>&lt;u>Steve O\'Shea&lt;/u>&lt;/b>&lt;/i> for providing recent bluetooth enabled devices for testing and ensuring forthcoming wireless connection support in the app (&lt;a href="https://apsystems.com.sg">Advanced Processing Systems Pte Ltd.&lt;/a>)&lt;/b>&lt;/i>&lt;/li>
        &lt;/ul>
        &lt;br/>
        The pretty freeware icons used by the app were obtained from &lt;a href="flaticon.com">flaticon.com&lt;/a> and their
        lovely sized transparent PNG enabled conversions of these images to standard sizes. The GIMP image editor on
        Linux has also been used to create custom icons and colored logos for this application.
    </string>
    <string name="privacyhtml">
        &lt;h1>User Privacy Policy&lt;/h1>
        A privacy policy for the application is now required and has been posted at the following link for the
        benefit of users:
        &lt;a href="https://github.com/maxieds/ChameleonMiniLiveDebugger/wiki/UserPrivacyPolicy">UserPrivacyPolicy&lt;/a>.
        If you have discovered this app by a search on the Google Play Store, notice that unmodified developer signed
        binaries are provided by the developer on the
        &lt;a href="https://github.com/maxieds/ChameleonMiniLiveDebugger/releases/latest">project latest releases&lt;/a> page on GitHub.
    </string>
    <string name="apphtmlheader">&lt;html>&lt;head>&lt;style>a { text-decoration: underline; color: %%ABOUTLINKCOLOR%%; font-weight: bold; font-style: italic; }&lt;/style>&lt;/head>&lt;body></string>
    <string name="apphtmlfooter">&lt;/body>&lt;/html></string>
    <string name="initialUserGreetingMsg">Thank you for using and testing this Android application.
               \nA detailed man page and instructions for using the
               \nChameleon Mini Live Debugger (CMLD) are found on
               \nthe project WIKI pages at the next link:\n
               https://github.com/maxieds/ChameleonMiniLiveDebugger/wiki.
               \n\nStay safe out there!
    </string>
    <string name="chameleonCmdAppendixTroubleshooting">
        Note that all of the different variations of the Chameleon Mini hardware devices do not all support the same
        commands. The commands supported by the device are programmed into the firmware that must be flashed onto the
        Chameleon device before you can use it.\n\n
        In particular, if you try to run a command with this CMLD application, and it fails for some reason, then most
        likely the device firmware you are using does not support this command. Some commands also require that they be
        run in a READER mode, whereas some commands must be run while the current active slot on the Chameleon is set to
        a configuration in SNIFFER mode.
    </string>
    <string name="chameleonScriptingForthcomingFeatures">
        The complete scripting functionality will be added in a future release of the CMLD application.
        For now there is only this placeholder available. A planned and proposed feature set for this
        batch or shell script like capability is described at the next project link:\n
        https://github.com/maxieds/ChameleonMiniLiveDebugger/projects/3\n\n
        Planned features include the following:\n
        • A logger tab like feature to view the script runtime output\n
        • A gdb debugger like window to view the post execution variable\n
          values set in the script
    </string>
    <string name="chameleonConfigAppendixTroubleshooting">
        A complete list of supported configurations is available from within the Tools | Config Slots tab for each
        of the slots available on the device.
    </string>
    <string name="apduEntryInstructions">
        Enter the APDU component bytes manually into the following box.\n\n
        The bytes are in hexadecimal in the following order: \n
        [CLA | INS | P1 | P2 | DATA-BYTES]\n\n
        Notes on the input data:\n
        • Note that the LE/LC fields found in wrapped APDUs should not be\n
          included and will be calculated based on your input later.\n
        • Bytes specified with \'xx\' will be ignored and the previously\n
          selected values in the assembled APDU bytes are preserved.
    </string>
    <string name="helpCmdResp">
        &lt;h1>Command Responses: &lt;/h1>
        Subsequent to any command sent, the Chameleon responds with a status number and a corresponding status message, separated by a colon and terminated with a carriage return and line feed (CR+LF, 0D+0A hexadecimal). Status numbers are of a three-digit decimal format with the first digit showing the severity of the answer. Status numbers beginning with a \'1\' denote an informational item and those beginning with a \'2\' denote an error.
        The following table lists the possible status return codes generated by the Chameleon &lt;br/>&lt;br/>
        &lt;table>
            &lt;tr>&lt;th>Response &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>100:OK&lt;/code> &lt;/td>&lt;td>The command has been successfully executed &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>101:OK WITH TEXT&lt;/code> &lt;/td>&lt;td>The command has been successfully executed and this response is appended with an additional line of information, terminated with CR+LF &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>110:WAITING FOR XMODEM&lt;/code> &lt;/td>&lt;td>The Chameleon is waiting for an XMODEM connection to be established &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>120:FALSE&lt;/code> &lt;/td>&lt;td>The request is answered with false &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>121:TRUE&lt;/code> &lt;/td>&lt;td>The request is answered with true &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>200:UNKNOWN COMMAND&lt;/code> &lt;/td>&lt;td>This command is unknown to the Chameleon &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>201:INVALID COMMAND USAGE&lt;/code> &lt;/td>&lt;td>This action is not supported by this command &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>202:INVALID PARAMETER&lt;/code> &lt;/td>&lt;td>The format or value of the given parameter value is invalid &lt;/td>&lt;/tr>
            &lt;tr>&lt;td>&lt;code>203:TIMEOUT&lt;/code> &lt;/td>&lt;td>The timeout of the currently active command has expired &lt;/td>&lt;/tr>
         &lt;/table>
    </string>
    <string name="helpRevECmds">
        &lt;h1>Chameleon RevE (Rebooted) Terminal Commands: &lt;/h1>
        &lt;h2>VERSIONMY&lt;/h2>
        Requests version information of the current firmware.
        &lt;h2>CONFIGMY&lt;/h2>
        Get/Set the configuration of the current slot.&lt;br>
        Note: The ChameleonMini has 8 possible slots (1-8)&lt;br>
        Returns a list of the available configurations&lt;br/>
        &lt;h2>UIDMY&lt;/h2>
        Returns the UID of a card in the current slot.&lt;br>
        Sets a new UID, passed in hexadecimal notation.&lt;br/>
        &lt;h2>READONLYMY&lt;/h2>
        Configures the read-only mode to the internal memory. Activates (1) or deactivates (0) the read-only mode (Any writing to the memory is silently ignored.)&lt;br>
        Print the possible states.&lt;br>
        Returns the current state of the read-only mode.&lt;br>
        &lt;h2>UPLOADMY&lt;/h2>
        Waits for an XModem connection in order to upload a new virtualized card into the currently selected slot, with a size up to the current memory size.
        &lt;h2>DOWNLOADMY&lt;/h2>
        Waits for an XModem connection in order to download a virtualized card with the current memory size.
        &lt;h2>RESETMY&lt;/h2>
        Reboots the Chameleon, i.e., power down and subsequent power-up. Note: A reset usually requires a new Terminal session.
        &lt;h2>UPGRADEMY&lt;/h2>
        Sets the Chameleon into firmware upgrade mode (DFU). This command can be used instead of holding the BUTTON while power-on to trigger the bootloader.
        &lt;h2>MEMSIZEMY&lt;/h2>
        Returns the memory size occupied by the current configuration in Byte.
        &lt;h2>UIDSIZEMY&lt;/h2>
        Returns the UID size of the currently selected card type in Byte.&lt;br>
        &lt;h2>BUTTONMY&lt;/h2>
        Get/Set the action for pressing the button shortly.&lt;br>
        Returns a list of the available button actions.&lt;br>
        &lt;h2>SETTINGMY&lt;/h2>
        Get/Set the active slot (number between 1 and 8) for the card/reader emulation (see Settings).
        &lt;h2>CLEARMY&lt;/h2>
        Clears the content of the current slot.&lt;br/>
        &lt;h2>HELPMY&lt;/h2>
        Returns a comma-separated list of all commands supported by the current firmware.
        &lt;h2>RSSIMY&lt;/h2>
        Returns the voltage measured at the antenna of the Chameleon, e.g., to detect the presence of an RF field or compare the field strength of different RFID readers.
        &lt;h2>DETECTIONMY&lt;/h2>
        Performs the MF Classic Key attack to a reader.
    </string>
    <string name="helpRevGCmds">
        &lt;adh1>Chameleon RevG Command Set: &lt;/h1>
        &lt;p>The current firmware supports the following global commands. &lt;/p>&lt;table class="doxtable">
        &lt;tr>
        &lt;th>Command &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>CHARGING?&lt;/code> &lt;/td>&lt;td>Returns if the battery is currently being charged (TRUE) or not (FALSE) &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>HELP&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of all commands supported by the current firmware &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RESET&lt;/code> &lt;/td>&lt;td>Reboots the Chameleon, i.e., power down and subsequent power-up. Note: A reset usually requires a new Terminal session. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RSSI?&lt;/code> &lt;/td>&lt;td>Returns the voltage measured at the antenna of the Chameleon, e.g., to detect the presence of an RF field or compare the field strength of different RFID readers. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>SYSTICK?&lt;/code> &lt;/td>&lt;td>Returns the system tick value in ms. Note: An overflow occurs every 65,536 ms. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>UPGRADE&lt;/code> &lt;/td>&lt;td>Sets the Chameleon into firmware upgrade mode (DFU). This command can be used instead of holding the RBUTTON while power-on to trigger the bootloader. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>VERSION?&lt;/code> &lt;/td>&lt;td>Requests version information of the current firmware &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;b>Button Commands&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported actions for pressing the right button shortly. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON?&lt;/code> &lt;/td>&lt;td>Returns the currently set action for pressing the right button shortly. DEFAULT: &lt;code>SETTING_CHANGE&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the action for pressing the right button shortly. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported actions for pressing the left button shortly. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON?&lt;/code> &lt;/td>&lt;td>Returns the currently set action for pressing the left button shortly. DEFAULT: &lt;code>RECALL_MEM&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the action for pressing the left button shortly. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON_LONG=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported actions for pressing the right button a long time. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON_LONG?&lt;/code> &lt;/td>&lt;td>Returns the currently set action for pressing the right button a long time. DEFAULT: &lt;code>SETTING_CHANGE&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RBUTTON_LONG=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the action for pressing the right button a long time. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON_LONG=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported actions for pressing the left button a long time. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON_LONG?&lt;/code> &lt;/td>&lt;td>Returns the currently set action for pressing the left button a long time. DEFAULT: &lt;code>RECALL_MEM&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LBUTTON_LONG=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the action for pressing the left button a long time. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;b>LED Commands&lt;/b> &lt;/td>&lt;td>&lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDGREEN=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported events for illuminating the green LED &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDGREEN?&lt;/code> &lt;/td>&lt;td>Returns the currently set event for lighting the green LED &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDGREEN=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the event for which the green LED is lit. DEFAULT: &lt;code>POWERED&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDRED=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported events for illuminating the red LED &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDRED?&lt;/code> &lt;/td>&lt;td>Returns the currently set event for lighting the red LED &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LEDRED=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the event for which the green LED is lit. DEFAULT: &lt;code>SETTING_CHANGE&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;b>Log Commands&lt;/b> &lt;/td>&lt;td>&lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGMODE=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of supported log modes &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGMODE?&lt;/code> &lt;/td>&lt;td>Returns the current state of the log mode &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGMODE=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the current log mode. DEFAULT = &lt;code>OFF&lt;/code> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGMEM?&lt;/code> &lt;/td>&lt;td>Returns the remaining free space for logging data to the SRAM (max. 2048 byte) &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGDOWNLOAD&lt;/code> &lt;/td>&lt;td>Waits for an XModem connection and then downloads the binary log - including any log data in FRAM. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGCLEAR&lt;/code> &lt;/td>&lt;td>Clears the log memory (SRAM and FRAM) &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>LOGSTORE&lt;/code> &lt;/td>&lt;td>Writes the current log from SRAM to FRAM and clears the SRAM log. &lt;dl class="section warning">&lt;dt>Warning&lt;/dt>&lt;dd>If the FRAM is full, currently no error message is shown. If calling &lt;code>LOGMEM?&lt;/code> after executing this command returns any other value than the maximum SRAM log size, there was not sufficient space in the FRAM and nothing has been done. &lt;/dd>&lt;/dl>
        &lt;/td>&lt;/tr>
        &lt;/table>
        &lt;p>ChameleonMini provides eight \'slots\' that can be configured to store different virtualized cards, or as active NFC reader, or as completely passive device for sniffing purposes. Each slot stores its configuration and, if applicable, card content. To select a particular slot, use the following command (or configure a button accordingly): &lt;/p>&lt;table class="doxtable">
        &lt;tr>
        &lt;th>Command &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>SETTING?&lt;/code> &lt;/td>&lt;td>Returns the currently activated slot &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>SETTING=&lt;NUMBER&gt;&lt;/code> &lt;/td>&lt;td>Sets the active slot, where &lt;NUMBER&gt; is a number between 1 and 8 (see &lt;a class="el" href="_page__settings.html">Settings&lt;/a>) &lt;/td>&lt;/tr>
        &lt;/table>
        &lt;p>The following commands have an effect on the currently selected slot only: &lt;/p>&lt;table class="doxtable">
        &lt;tr>
        &lt;th>Command &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>CONFIG=?&lt;/code> &lt;/td>&lt;td>Returns a comma-separated list of all supported configurations &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>CONFIG?&lt;/code> &lt;/td>&lt;td>Returns the configuration of the current slot &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>CONFIG=&lt;NAME&gt;&lt;/code> &lt;/td>&lt;td>Sets the configuration of the surrent slot to &lt;code>&lt;NAME&gt;&lt;/code> (See &lt;a class="el" href="_page__configurations.html">Configurations&lt;/a>) &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>UIDSIZE?&lt;/code> &lt;/td>&lt;td>Returns the UID size of the currently selected card type in Byte &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>UID?&lt;/code> &lt;/td>&lt;td>Returns the UID of a card in the current slot &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>UID=&lt;UID&gt;&lt;/code> &lt;/td>&lt;td>Sets a new UID, passed in hexadecimal notation. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>READONLY?&lt;/code> &lt;/td>&lt;td>Returns the current state of the read-only mode &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>READONLY=[0;1]&lt;/code> &lt;/td>&lt;td>Activates (1) or deactivates (0) the read-only mode (Any writing to the memory is silently ignored) &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>MEMSIZE?&lt;/code> &lt;/td>&lt;td>Returns the memory size occupied by the current configuration in Byte &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>UPLOAD&lt;/code> &lt;/td>&lt;td>Waits for an XModem connection in order to upload a new virtualized card into the currently selected slot, with a size up to the current memory size &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>DOWNLOAD&lt;/code> &lt;/td>&lt;td>Waits for an XModem connection in order to download a virtualized card with the current memory size &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>CLEAR&lt;/code> &lt;/td>&lt;td>Clears the content of the current slot &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>STORE&lt;/code> &lt;/td>&lt;td>Stores the content of the current slot from FRAM into the Flash memory &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>RECALL&lt;/code> &lt;/td>&lt;td>Recalls/restores the content of the current slot from the Flash memory into the FRAM &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>TIMEOUT=?&lt;/code> &lt;/td>&lt;td>Returns the possible number range for timeouts. See also &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout commands&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>TIMEOUT=&lt;NUMBER&gt;&lt;/code> &lt;/td>&lt;td>Sets the timeout for the current slot in multiples of 128 ms. If set to zero, there is no timeout. See also &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout commands&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>TIMEOUT?&lt;/code> &lt;/td>&lt;td>Returns the timeout for the current slot. See also &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout commands&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;b>Reader Commands&lt;/b>&lt;/td>&lt;td>Using these commands only makes sense, if the slot is configured as reader. See also &lt;a class="el" href="_page_14443_a_reader.html">ISO14443A Reader Functionality&lt;/a> &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>SEND &lt;BYTEVALUE&gt;&lt;/code> &lt;/td>&lt;td>Adds parity bits, sends the given byte string &lt;BYTEVALUE&gt;, and returns the cards answer &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>SEND_RAW &lt;BYTEVALUE&gt;&lt;/code>&lt;/td>&lt;td>Does NOT add parity bits, sends the given byte string &lt;BYTEVALUE&gt; and returns the cards answer &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>GETUID&lt;/code> &lt;/td>&lt;td>Obtains the UID of a card that is in the range of the antenna and returns it. This command is a &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout command&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>DUMP_MFU&lt;/code> &lt;/td>&lt;td>Reads the whole content of a Mifare Ultralight card that is in the range of the antenna and returns it. This command is a &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout command&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>IDENTIFY&lt;/code> &lt;/td>&lt;td>Identifies the type of a card in the range of the antenna and returns it. This command is a &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout command&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>THRESHOLD=?&lt;/code> &lt;/td>&lt;td>Returns the possible number range for the reader threshold. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>THRESHOLD=&lt;NUMBER&gt;&lt;/code> &lt;/td>&lt;td>Globally sets the reader threshold. The &lt;NUMBER&gt; influences the reader function and range. Setting a wrong value may result in malfunctioning of the reader. DEFAULT: 400 &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>THRESHOLD?&lt;/code> &lt;/td>&lt;td>Returns the current reader threshold. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>AUTOCALIBRATE&lt;/code> &lt;/td>&lt;td>Automatically finds a good threshold for communicating with the card that currently is on top of the Chameleon. This command is a &lt;a class="el" href="_page__command_line.html#Anchor_TimeoutCommands">Timeout command&lt;/a>. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>FIELD?&lt;/code> &lt;/td>&lt;td>Returns whether (1) or not (0) the reader field is active. &lt;/td>&lt;/tr>
        &lt;tr>
        &lt;td>&lt;code>FIELD=[0;1]&lt;/code> &lt;/td>&lt;td>Enables/disables the reader field. &lt;/td>&lt;/tr>
        &lt;/table>
    </string>
    <string name="helpButtonSettings">
        &lt;h1>Supported Button Configurations: &lt;/h1>
        &lt;p>The following table describes all currently implemented options for the button configuration. &lt;/p>
        &lt;table class="doxtable">
            &lt;tr>
            &lt;th>Configuration name &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>NONE&lt;/code> &lt;/td>&lt;td>No function, the button is disabled &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>UID_RANDOM&lt;/code> &lt;/td>&lt;td>Sets a random UID for the current card slot. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>UID_LEFT_INCREMENT&lt;/code> &lt;/td>&lt;td>Increments the UID for the current card slot. The UID is interpreted as little-endian. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>UID_RIGHT_INCREMENT&lt;/code>&lt;/td>&lt;td>Increments the UID for the current card slot. The UID is interpreted as big-endian. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>UID_LEFT_DECREMENT&lt;/code> &lt;/td>&lt;td>Decrements the UID for the current card slot. The UID is interpreted as little-endian. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>UID_RIGHT_DECREMENT&lt;/code>&lt;/td>&lt;td>Decrements the UID for the current card slot. The UID is interpreted as big-endian. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>CYCLE_SETTINGS&lt;/code> &lt;/td>&lt;td>Cycles through the slots/settings. If the configuration of a slot is set to &lt;code>NONE&lt;/code>, this slot is skipped. When the last slot is reached, the next button press selects the first slot, again. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>STORE_MEM&lt;/code> &lt;/td>&lt;td>Stores the current setting into the permanent Flash memory. Equivalent to the &lt;code>STORE&lt;/code> command. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>RECALL_MEM&lt;/code> &lt;/td>&lt;td>Recalls a setting from the permanent Flash memory. Equivalent to the &lt;code>RECALL&lt;/code> command. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>TOGGLE_FIELD&lt;/code> &lt;/td>&lt;td>Activates the reader field if it was deactivated, deactivates the reader field if it was activated. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>STORE_LOG&lt;/code> &lt;/td>&lt;td>Writes the current log from SRAM to FRAM and clears the SRAM log. Equivalent to the &lt;code>STORE_LOG&lt;/code> command. &lt;/td>&lt;/tr>
    &lt;/table>
    </string>
    <string name="helpLEDSettings">
        &lt;h1>LED Settings: &lt;/h1>
        &lt;p>The Chameleon-Mini has two fully configurable LEDs: one red LED and one green LED. The configuration is done with the commands &lt;code>LEDRED&lt;/code> and &lt;code>LEDGREEN&lt;/code>, which both can be called as the getting ("?"), setting ("=") and suggesting ("=?") version. The following table shows which LED functions are currently available. &lt;/p>
        &lt;table class="doxtable">
            &lt;tr>
            &lt;th>Function name &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>NONE&lt;/code> &lt;/td>&lt;td>No function, the LED is deactivated. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>POWERED&lt;/code> &lt;/td>&lt;td>The LED lights up if the Chameleon-Mini is powered, regardless whether powered by USB or by battery. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>TERMINAL_CONN&lt;/code> &lt;/td>&lt;td>The LED is turned on when the Chameleon-Mini is connected via USB and is turned off when no USB connection is established. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>TERMINAL_RXTX&lt;/code> &lt;/td>&lt;td>The according LED blinks shortly when sending or receiving data via the USB interface. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>SETTING_CHANGE&lt;/code> &lt;/td>&lt;td>The LED blinks one time if the new setting is setting 1, two times for setting 2, ..., eight times for setting 8. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>MEMORY_STORED&lt;/code> &lt;/td>&lt;td>The LED flashes everytime when a setting is stored to the permanent flash. This is currently the case when calling the command &lt;code>STORE&lt;/code>, the button event &lt;code>STORE_MEM&lt;/code> occurs or the setting is changed. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>MEMORY_CHANGED&lt;/code> &lt;/td>&lt;td>The LED turns on when the FRAM is changed and is turned off when the currently active setting is written to the permanent flash. Thus, this function indicates when the current setting is changed. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>CODEC_RX&lt;/code> &lt;/td>&lt;td>The LED flashes when the currently active codec (e.g. ISO14443A emulation) receives data. Note that this is implemented on codec layer and the flashing is triggered before the received data are interpreted by the application. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>CODEC_TX&lt;/code> &lt;/td>&lt;td>The LED flashes when the currently active codec sends data. This function also is implemented on codec layer. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>FIELD_DETECTED&lt;/code> &lt;/td>&lt;td>The LED is turned on if and only if a reader field is detected, which is recognized by the RSSI module (when the RSSI value hits a hardcoded threshold, it is assumed that there is a reader field). It is irrelevant whether the field comes from another reader or from the Chameleon-Mini itself. &lt;/td>&lt;/tr>
            &lt;tr>
            &lt;td>&lt;code>LOGMEM_FULL&lt;/code> &lt;/td>&lt;td>Lights up the LED, if the SRAM log memory is full. &lt;/td>&lt;/tr>
        &lt;/table>
    </string>
    <string name="helpLogging">
        &lt;h1>Log Entry Format: &lt;/h1>
        &lt;table class="doxtable">
           &lt;tr>
           &lt;th>Name &lt;/th>&lt;th>Size &lt;/th>&lt;th>Description  &lt;/th>&lt;/tr>
           &lt;tr>
           &lt;td>Entry type &lt;/td>&lt;td>1 byte &lt;/td>&lt;td>See &lt;a class="el" href="_log_8h.html#a34112fbd78128ae58dc7801690dfa6e0">LogEntryEnum&lt;/a> &lt;/td>&lt;/tr>
           &lt;tr>
           &lt;td>Data length &lt;/td>&lt;td>1 byte &lt;/td>&lt;td>This is the length of the appended data. &lt;/td>&lt;/tr>
           &lt;tr>
           &lt;td>Timestamp &lt;/td>&lt;td>2 bytes &lt;/td>&lt;td>This is the current systick value. &lt;/td>&lt;/tr>
           &lt;tr>
           &lt;td>Data &lt;/td>&lt;td>&lt;em>Data length&lt;/em> bytes &lt;/td>&lt;td>It is also possible that no data is appended, then the &lt;code>Data length&lt;/code> field is zero. &lt;/td>&lt;/tr>
        &lt;/table>
        &lt;h1>LogEntryEnum: &lt;/h1>
        &lt;table class="fieldtable">
            &lt;tr>&lt;tr>&lt;td class="fieldname">LOG_INFO_GENERIC&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Unspecific log entry. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_CONFIG_SET&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Configuration change. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_SETTING_SET&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Setting change. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_UID_SET&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>UID change. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_RESET_APP&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application reset. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_CODEC_RX_DATA&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Currently active codec received data. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_CODEC_TX_DATA&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Currently active codec sent data. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_CODEC_RX_DATA_W_PARITY&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Currently active codec received data. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_CODEC_TX_DATA_W_PARITY&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Currently active codec sent data. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_READ&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed read command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_WRITE&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed write command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_INC&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed increment command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_DEC&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed decrement command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_TRANSFER&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed transfer command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_RESTORE&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed restore command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_AUTH&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed authentication command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_HALT&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed halt command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_CMD_UNKNOWN&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application processed an unknown command. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_AUTHING&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application is in &lt;code>authing&lt;/code> state. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_APP_AUTHED&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application is in &lt;code>auth&lt;/code> state. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_ERR_APP_AUTH_FAIL&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application authentication failed. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_ERR_APP_CHECKSUM_FAIL&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application had a checksum fail. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_ERR_APP_NOT_AUTHED&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Application is not authenticated. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_INFO_SYSTEM_BOOT&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Chameleon boots. &lt;/p>
            &lt;/td>&lt;/tr>
            &lt;tr>&lt;td class="fieldname">LOG_EMPTY&#160;&lt;/td>&lt;td class="fielddoc">&lt;p>Empty Log Entry. This is not followed by a length byte nor the two systick bytes nor any data. &lt;/p>
            &lt;/td>&lt;/tr>
        &lt;/table>
        &lt;h1>Log Modes: &lt;/h1>
        &lt;p>Currently there exist three log modes:&lt;/p>
        &lt;ul>
            &lt;li>&lt;code>OFF&lt;/code>, which means that nothing is logged.&lt;/li>
            &lt;li>&lt;code>LIVE&lt;/code>, which means that log events are written directly to the terminal (untested).&lt;/li>
            &lt;li>&lt;code>MEMORY&lt;/code>, where the log events are written to SRAM.&lt;/li>
        &lt;/ul>
    </string>

    <string-array name="RButtonOptions">
        <item>RBUTTON</item>
        <item>NONE</item>
        <item>UID_RANDOM</item>
        <item>UID_LEFT_INCREMENT</item>
        <item>UID_RIGHT_INCREMENT</item>
        <item>UID_LEFT_DECREMENT</item>
        <item>UID_RIGHT_DECREMENT</item>
        <item>CYCLE_SETTINGS</item>
        <item>STORE_MEM</item>
        <item>RECALL_MEM</item>
        <item>TOGGLE_FIELD</item>
        <item>STORE_LOG</item>
    </string-array>

    <string-array name="RButtonLongOptions">
        <item>RBUTTON_LONG</item>
        <item>NONE</item>
        <item>UID_RANDOM</item>
        <item>UID_LEFT_INCREMENT</item>
        <item>UID_RIGHT_INCREMENT</item>
        <item>UID_LEFT_DECREMENT</item>
        <item>UID_RIGHT_DECREMENT</item>
        <item>CYCLE_SETTINGS</item>
        <item>STORE_MEM</item>
        <item>RECALL_MEM</item>
        <item>TOGGLE_FIELD</item>
        <item>STORE_LOG</item>
    </string-array>

    <string-array name="LButtonOptions">
        <item>LBUTTON</item>
        <item>NONE</item>
        <item>UID_RANDOM</item>
        <item>UID_LEFT_INCREMENT</item>
        <item>UID_RIGHT_INCREMENT</item>
        <item>UID_LEFT_DECREMENT</item>
        <item>UID_RIGHT_DECREMENT</item>
        <item>CYCLE_SETTINGS</item>
        <item>STORE_MEM</item>
        <item>RECALL_MEM</item>
        <item>TOGGLE_FIELD</item>
        <item>STORE_LOG</item>
    </string-array>

    <string-array name="LButtonLongOptions">
        <item>LBUTTON_LONG</item>
        <item>NONE</item>
        <item>UID_RANDOM</item>
        <item>UID_LEFT_INCREMENT</item>
        <item>UID_RIGHT_INCREMENT</item>
        <item>UID_LEFT_DECREMENT</item>
        <item>UID_RIGHT_DECREMENT</item>
        <item>CYCLE_SETTINGS</item>
        <item>STORE_MEM</item>
        <item>RECALL_MEM</item>
        <item>TOGGLE_FIELD</item>
        <item>STORE_LOG</item>
    </string-array>

    <string-array name="LEDRedOptions">
        <item>LEDRED</item>
        <item>NONE</item>
        <item>POWERED</item>
        <item>TERMINAL_CONN</item>
        <item>TERMINAL_RXTX</item>
        <item>SETTING_CHANGE</item>
        <item>MEMORY_STORED</item>
        <item>MEMORY_CHANGED</item>
        <item>CODEC_RX</item>
        <item>CODEC_TX</item>
        <item>FIELD_DETECTED</item>
        <item>LOGMEM_FULL</item>
    </string-array>

    <string-array name="LEDGreenOptions">
        <item>LEDGREEN</item>
        <item>NONE</item>
        <item>POWERED</item>
        <item>TERMINAL_CONN</item>
        <item>TERMINAL_RXTX</item>
        <item>SETTING_CHANGE</item>
        <item>MEMORY_STORED</item>
        <item>MEMORY_CHANGED</item>
        <item>CODEC_RX</item>
        <item>CODEC_TX</item>
        <item>FIELD_DETECTED</item>
        <item>LOGMEM_FULL</item>
    </string-array>

    <string-array name="ButtonMyRevEBoards">
        <item>BUTTON_REVE</item>
        <item>NONE</item>
        <item>RANDOM_UID</item>
        <item>UID_LEFT_INCREMENT</item>
        <item>UID_RIGHT_INCREMENT</item>
        <item>UID_LEFT_DECREMENT</item>
        <item>UID_RIGHT_DECREMENT</item>
        <item>SWITCHCARD</item>
    </string-array>

    <string-array name="LogModeOptions">
        <item>LIVE</item>
        <item>LIVE-NOTIFY</item>
        <item>MEMORY</item>
        <item>OFF</item>
        <item>OFF-NOTIFY</item>
    </string-array>

    <string-array name="FullCommandList">
        <item>--Advanced Chameleon Shell (RevG)--</item>
        <item>CLEAR</item>
        <item>RANDOM UID</item>
        <item>RECALL</item>
        <item>SETTING=</item>
        <item>STORE</item>
        <item>THRESHOLD=?</item>
        <item>TIMEOUT=</item>
        <item>TIMEOUT=?</item>
        <item>UID=</item>
        <item>UID?</item>
    </string-array>

    <string-array name="FullTagConfigModes">
        <item>NONE</item>
        <item>EM4233</item>
        <item>ISO14443A_SNIFF</item>
        <item>ISO14443A_READER</item>
        <item>ISO15693_SNIFF</item>
        <item>MF_CLASSIC_1K</item>
        <item>MF_CLASSIC_1K_7B</item>
        <item>MF_CLASSIC_4K</item>
        <item>MF_CLASSIC_4K_7B</item>
        <item>MF_CLASSIC_MINI_4B</item>
        <item>MF_DESFIRE</item>
        <item>MF_DETECTION</item>
        <item>MF_DETECTION_4K</item>
        <item>MF_ULTRALIGHT</item>
        <item>MF_ULTRALIGHT_C</item>
        <item>MF_ULTRALIGHT_EV1_80B</item>
        <item>MF_ULTRALIGHT_EV1_164B</item>
        <item>NTAG215</item>
        <item>SL2S2002</item>
        <item>TITAGITSTANDARD</item>
        <item>VICINITY</item>
    </string-array>

</resources>
